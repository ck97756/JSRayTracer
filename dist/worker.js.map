{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/RMath.js","webpack:///./src/Ray.js","webpack:///./src/Shading.js","webpack:///./src/Object.js","webpack:///./src/scene.js","webpack:///./src/RayTracer.worker.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Vec3","[object Object]","arguments","length","this","x","y","z","scale","scaleToLength","Math","sqrt","multiply","dot","normalize","Vec2","floor","Ray_Ray","startPosition","direction","iterationCount","weight","absort","iterationCounter","ior","Shading_Material","BRDF","materialParam","baseColor","generateRays","ray","position","normal","material","numberOfRay","multiplyByVec3","newRays","Array","totalEnergy","lightCount","generateDirection","energy","newRay","undefined","diffuseBRDF","negative","random","Object_Sphere","radius","rayToCenter","minus","a","b","Number","POSITIVE_INFINITY","root","squrD","collisionPosition","plus","camera","lookAt","top","focus","size","canvasSize","viewDir","leftVector","cross","topVector","scene_objects","scene_material","sphere","push","light","color","traceRay","rays","objects","distance","collisionFunction","collision","getCollision","next","setView","onmessage","event","eventType","data","type","samplePerPixel","pow","console","log","cameraSize","rangeStart","rangeEnd","width","height","Uint8ClampedArray","halfCameraSize","divide","step","divideByVec2","focusPosition","focusToTopLeft","samplePoint","index","postMessage"],"mappings":"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","file":"worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export class Vec3 {\r\n\tconstructor() {\r\n\t\tif (arguments.length === 1 && arguments[0] instanceof Vec3) {\r\n\t\t\tthis.x = arguments[0].x;\r\n\t\t\tthis.y = arguments[0].y;\r\n\t\t\tthis.z = arguments[0].z;\r\n\t\t} else if (arguments.length === 3) {\r\n\t\t\tthis.x = arguments[0];\r\n\t\t\tthis.y = arguments[1];\r\n\t\t\tthis.z = arguments[2];\r\n\t\t} else {\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tplus(r) {\r\n\t\treturn new Vec3(\r\n\t\t\tthis.x + r.x\r\n\t\t\t, this.y + r.y\r\n\t\t\t, this.z + r.z\r\n\t\t);\r\n\t}\r\n\r\n\tminus(r) {\r\n\t\treturn new Vec3(\r\n\t\t\tthis.x - r.x\r\n\t\t\t, this.y - r.y\r\n\t\t\t, this.z - r.z\r\n\t\t);\r\n\t}\r\n\r\n\tmultiply(r) {\r\n\t\treturn new Vec3(\r\n\t\t\tthis.x * r\r\n\t\t\t, this.y * r\r\n\t\t\t, this.z * r\r\n\t\t);\r\n\t}\r\n\r\n\tscaleToLength(l) {\r\n\t\tlet length = this.length();\r\n\t\tlet scale = l / length;\r\n\t\treturn new Vec3(\r\n\t\t\tthis.x * scale\r\n\t\t\t, this.y * scale\r\n\t\t\t, this.z * scale\r\n\t\t);\r\n\t}\r\n\r\n\tnormalize() {\r\n\t\treturn this.scaleToLength(1);\r\n\t}\r\n\r\n\tcross(r) {\r\n\t\treturn new Vec3(\r\n\t\t\tthis.y * r.z - this.z * r.y\r\n\t\t\t, this.z * r.x - this.x * r.z\r\n\t\t\t, this.x * r.y - this.y * r.x\r\n\t\t);\r\n\t}\r\n\r\n\tlength() {\r\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\r\n\t}\r\n\r\n\tdot(r) {\r\n\t\treturn this.x * r.x + this.y * r.y + this.z * r.z;\r\n\t}\r\n\r\n\tnegative() {\r\n\t\treturn new Vec3(\r\n\t\t\t-this.x\r\n\t\t\t, -this.y\r\n\t\t\t, -this.z\r\n\t\t);\r\n\t}\r\n\r\n\tmultiplyByVec3(r) {\r\n\t\treturn new Vec3(\r\n\t\t\tthis.x * r.x\r\n\t\t\t, this.y * r.y\r\n\t\t\t, this.z * r.z\r\n\t\t);\r\n\t}\r\n\r\n\tdivide(r) {\r\n\t\treturn new Vec3(\r\n\t\t\tthis.x / r\r\n\t\t\t, this.y / r\r\n\t\t\t, this.z / r\r\n\t\t);\r\n\t}\r\n\r\n\tprojectOnto(r) {\r\n\t\treturn r.multiply(this.dot(r.normalize()));\r\n\t}\r\n\r\n\tprojectLength(r) {\r\n\t\treturn this.dot(r.normalize());\r\n\t}\r\n}\r\n\r\nexport class Vec2 {\r\n\tconstructor() {\r\n\t\tif (arguments.length === 1 && arguments[0] instanceof Vec2) {\r\n\t\t\tthis.x = arguments[0].x;\r\n\t\t\tthis.y = arguments[0].y;\r\n\t\t} else if (arguments.length === 2) {\r\n\t\t\tthis.x = arguments[0];\r\n\t\t\tthis.y = arguments[1];\r\n\t\t} else {\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tdivide(r) {\r\n\t\treturn new Vec2(this.x / r, this.y / r);\r\n\t}\r\n\r\n\tdivideByVec2(r) {\r\n\t\treturn new Vec2(this.x / r.x, this.y / r.y);\r\n\t}\r\n\r\n\tmultiplyByVec2(r) {\r\n\t\treturn new Vec2(this.x * r.x, this.y * r.y);\r\n\t}\r\n\r\n\tfloor() {\r\n\t\treturn new Vec2(Math.floor(this.x), Math.floor(this.y));\r\n\t}\r\n\r\n\tlength() {\r\n\t\treturn Math.sqrt(this.x * this.x + this.y * this.y);\r\n\t}\r\n}\r\n\r\nexport class Quaternion {\r\n\tconstructor(w, x, y, z) {\r\n\t\tthis.w = w;\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t}\r\n}","import { Vec3 } from './RMath';\r\n\r\nexport class Ray{\r\n\tconstructor(startPosition, direction, iterationCount, weight, absort) {\r\n\t\tthis.startPosition = startPosition;\r\n\t\tif (direction === null) {\r\n\t\t\tthis.direction = null;\r\n\t\t} else {\r\n\t\t\tthis.direction = direction.normalize();\r\n\t\t}\r\n\t\tthis.iterationCounter = iterationCount;\r\n\t\tthis.weight = weight;\r\n\t\tthis.absort = absort ? new Vec3(absort) : new Vec3(1, 1, 1);\r\n\t\tthis.ior = 1.000277;\r\n\t}\r\n}","import { Vec3 } from \"./RMath\";\r\nimport { Ray } from \"./Ray\";\r\nimport { isDebugging } from \"./debug\";\r\n\r\nexport class Material {\r\n\tconstructor(BRDF, materialParam) {\r\n\t\tthis.BRDF = BRDF;\r\n\t\tthis.baseColor = materialParam.baseColor || new Vec3(1, 1, 1);\r\n\t\tthis.materialParam = materialParam;\r\n\t}\r\n}\r\n\r\nexport function generateRays(ray, position, normal, material, numberOfRay) {\r\n\tlet BRDF = material.BRDF;\r\n\tlet absort = ray.absort.multiplyByVec3(material.baseColor);\r\n\tif (BRDF.numberOfRay === null) {\r\n\t\treturn null;\r\n\t}\r\n\tif (BRDF.numberOfRay && numberOfRay > BRDF.numberOfRay) {\r\n\t\tnumberOfRay = BRDF.numberOfRay;\r\n\t}\r\n\tlet newRays = new Array(numberOfRay);\r\n\tlet totalEnergy = BRDF.totalEnergy(numberOfRay);\r\n\tfor (let lightCount = 0; lightCount < numberOfRay; lightCount++) {\r\n\t\tlet direction = BRDF.generateDirection(normal, ray, material);\r\n\t\tlet energy = BRDF.BRDF(normal, direction);\r\n\t\tlet newRay = new Ray(position, direction, ray.iterationCounter + 1, energy / totalEnergy, absort);\r\n\t\tif (material.materialParam.ior !== undefined) {\r\n\t\t\tnewRay.ior = material.materialParam.ior;\r\n\t\t}\r\n\t\tnewRays[lightCount] = newRay;\r\n\t}\r\n\r\n\treturn newRays;\r\n}\r\n\r\nexport const diffuseBRDF = {\r\n\tgenerateDirection(normal, ray) {\r\n\t\tif (normal.dot(ray.direction) > 0) {\r\n\t\t\tnormal = normal.negative();\r\n\t\t}\r\n\t\tlet direction = new Vec3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\r\n\t\twhile (direction.dot(normal) < 0.1) {\r\n\t\t\tdirection = direction.negative();\r\n\t\t\tif (direction.dot(normal) < 0.1) {\r\n\t\t\t\tdirection = new Vec3(Math.random() * 2 - 1, Math.random() * 2 - 1, Math.random() * 2 - 1).normalize();\r\n\t\t\t} else {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn direction;\r\n\t}\r\n\t, totalEnergy(numberOfRay) {\r\n\t\treturn numberOfRay;\r\n\t}\r\n\t, BRDF() {\r\n\t\treturn 1;\r\n\t}\r\n};\r\n\r\nexport const emissionBRDF = {\r\n\tnumberOfRay: null\r\n};\r\n\r\nexport const reflectionBRDF = {\r\n\tgenerateDirection(normal, ray) {\r\n\t\tlet direction = normal.multiply(2).minus(ray.direction);\r\n\t\treturn direction;\r\n\t}\r\n\t, totalEnergy() {\r\n\t\treturn 1;\r\n\t}\r\n\t, BRDF() {\r\n\t\treturn 1;\r\n\t}\r\n\t, numberOfRay: 1\r\n};","import { Vec3, Vec2 } from \"./RMath\";\r\nimport { isDebugging } from './debug';\r\nimport { generateRays, diffuseBRDF, reflectionBRDF, Material } from \"./Shading\";\r\n\r\nexport class Sphere {\r\n\tconstructor() {\r\n\t\tif (arguments.length >= 2) {\r\n\t\t\tif (arguments[0] instanceof Vec3) {\r\n\t\t\t\tthis.position = new Vec3(arguments[0]);\r\n\t\t\t} else {\r\n\t\t\t\tthrow 'The first argument of constructor of Sphere must be type of Vec3';\r\n\t\t\t}\r\n\t\t\tif (typeof arguments[1] === 'number' && arguments[1] >= 0) {\r\n\t\t\t\tthis.radius = arguments[1];\r\n\t\t\t} else {\r\n\t\t\t\tthrow 'The second argument of constructor of Sphere must be a nonnegative number';\r\n\t\t\t}\r\n\t\t\tif (arguments.length > 2) {\r\n\t\t\t\tif (arguments[2] instanceof Material) {\r\n\t\t\t\t\tthis.material = arguments[2];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthrow 'The third argument of constructor of Sphere must be type of Material';\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.material = new Material(diffuseBRDF);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tthis.position = new Vec3();\r\n\t\t\tthis.radius = 1.0;\r\n\t\t\tthis.material = new Material(diffuseBRDF);\r\n\t\t}\r\n\t}\r\n\r\n\t* getCollision(ray) {\r\n\t\tlet rayToCenter = ray.startPosition.minus(this.position);\r\n\t\tlet a = ray.direction.dot(ray.direction);\r\n\t\tlet b = 2 * ray.direction.dot(rayToCenter);\r\n\t\tlet c = rayToCenter.dot(rayToCenter) - this.radius * this.radius;\r\n\t\tconst threshold = 1e-5;\r\n\t\t// b^2 - 4ac;\r\n\t\tlet d = b * b - 4 * a * c;\r\n\t\tlet l;\r\n\t\tif (d < 0) {\r\n\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t} else if (d === 0) {\r\n\t\t\tlet root = -b / (2 * a);\r\n\t\t\tif (root > 0) {\r\n\t\t\t\tl = root;\r\n\t\t\t\tif (l < threshold) {\r\n\t\t\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tyield l;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tlet squrD = Math.sqrt(d);\r\n\t\t\tlet root = -b - squrD;\r\n\t\t\tif (root > 0) {\r\n\t\t\t\tl = root / (2 * a);\r\n\t\t\t\tif (l < threshold) {\r\n\t\t\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tyield l;\r\n\t\t\t\t}\r\n\t\t\t} else if ((root = -b + squrD) > 0) {\r\n\t\t\t\tl = root / (2 * a);\r\n\t\t\t\tif (l < threshold) {\r\n\t\t\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tyield l;\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t\t}\r\n\t\t}\r\n\t\tlet collisionPosition = ray.startPosition.plus(ray.direction.multiply(l));\r\n\t\tlet normal = collisionPosition.minus(this.position).normalize();\r\n\t\tlet newRays = generateRays(ray, collisionPosition, normal, this.material, 1);\r\n\t\tyield newRays;\r\n\t\tif (newRays === null) {\r\n\t\t\tyield this.material.baseColor;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport class Plane {\r\n\tconstructor(position, firstVec, secondVec, material) {\r\n\t\tthis.position = new Vec3(position);\r\n\t\tthis.firstVec = new Vec3(firstVec);\r\n\t\tthis.secondVec = new Vec3(secondVec);\r\n\t\tthis.normal = this.firstVec.cross(this.secondVec).normalize();\r\n\t\tthis.material = material;\r\n\t}\r\n\r\n\t*getCollision(ray) {\r\n\t\tconst threshold = 1e-5;\r\n\r\n\t\tlet h = ray.direction.cross(this.secondVec);\r\n\t\tlet a = this.firstVec.dot(h);\r\n\t\tif (a > -threshold && a < threshold) {\r\n\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t}\r\n\r\n\t\tlet f = 1 / a;\r\n\t\tlet s = ray.startPosition.minus(this.position);\r\n\t\tlet u = f * s.dot(h);\r\n\r\n\t\tif (u < 0 || u > 1) {\r\n\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t}\r\n\r\n\t\tlet q = s.cross(this.firstVec);\r\n\t\tlet v = f * ray.direction.dot(q);\r\n\t\tif (v < 0 || v > 1) {\r\n\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t}\r\n\r\n\t\tlet t = f * this.secondVec.dot(q);\r\n\t\tif (t > threshold) {\r\n\t\t\tyield t;\r\n\t\t} else {\r\n\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t}\r\n\r\n\t\tlet normal = this.normal;\r\n\t\tif (normal.dot(ray.direction) > 0) {\r\n\t\t\tnormal = normal.negative();\r\n\t\t}\r\n\t\tlet collisionPosition = ray.startPosition.plus(ray.direction.multiply(t));\r\n\t\tlet newRays = generateRays(ray, collisionPosition, normal, this.material, 1);\r\n\t\tyield newRays;\r\n\t\tif (newRays === null) {\r\n\t\t\tyield this.material.baseColor;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport class DirectionalLight {\r\n\tconstructor(direction, color) {\r\n\t\tthis.direction = direction.normalize();\r\n\t\tthis.color = new Vec3(color);\r\n\t}\r\n\r\n\t* getCollision(ray) {\r\n\t\tif (ray.iterationCounter > 0 && this.direction.negative().dot(ray.direction) > 0) {\r\n\t\t\tyield 1e9;\r\n\t\t\tyield null;\r\n\t\t\tyield this.color;\r\n\t\t} else {\r\n\t\t\tyield Number.POSITIVE_INFINITY;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport class Camera {\r\n\tconstructor() {\r\n\t\tthis.position = new Vec3();\r\n\t\tthis.lookAt = new Vec3();\r\n\t\tthis.top = new Vec3(0, 0, 1);\r\n\t\tthis.focus = 0;\r\n\t\tthis.size = new Vec2();\r\n\t\tthis.canvasSize = new Vec2();\r\n\t}\r\n\r\n\tsetView(position, lookAt, top) {\r\n\t\tthis.position = new Vec3(position);\r\n\t\tthis.lookAt = new Vec3(lookAt);\r\n\t\tthis.top = new Vec3(top);\r\n\r\n\t\tlet viewDir = this.lookAt.minus(this.position);\r\n\t\tthis.leftVector = this.top.cross(viewDir).normalize();\r\n\t\tthis.topVector = viewDir.cross(this.leftVector).normalize();\r\n\t}\r\n}","import { Sphere, DirectionalLight, Plane, Camera} from './Object';\r\nimport { Vec3 } from './RMath';\r\nimport { Material, diffuseBRDF, reflectionBRDF, emissionBRDF } from './Shading';\r\n\r\nexport let camera = new Camera();\r\nexport let objects = [];\r\n\r\n\r\n// Cornell box\r\n// let material = new Material(reflectionBRDF, { baseColor: new Vec3(1, 1, 1) });\r\n// let sphere = new Sphere(new Vec3(-2, -3, 1), 2, material);\r\n// objects.push(sphere);\r\n\r\n// material = new Material(diffuseBRDF, { baseColor: new Vec3(1, 1, 0) });\r\n// sphere = new Sphere(new Vec3(2, -3, -1), 2, material);\r\n// objects.push(sphere);\r\n\r\n// material = new Material(diffuseBRDF, { baseColor: new Vec3(1, 0, 0) });\r\n// let plane = new Plane(new Vec3(5, 5, 5), new Vec3(0, 0, -10), new Vec3(0, -10, 0), material);\r\n// objects.push(plane);\r\n// material = new Material(diffuseBRDF, { baseColor: new Vec3(1, 1, 1) });\r\n// plane = new Plane(new Vec3(5, 5, 5), new Vec3(-10, 0, 0), new Vec3(0, -10, 0), material);\r\n// objects.push(plane);\r\n// material = new Material(diffuseBRDF, { baseColor: new Vec3(0, 1, 0) });\r\n// plane = new Plane(new Vec3(-5, 5, 5), new Vec3(0, 0, -10), new Vec3(0, -10, 0), material);\r\n// objects.push(plane);\r\n// material = new Material(diffuseBRDF, { baseColor: new Vec3(1, 1, 1) });\r\n// plane = new Plane(new Vec3(5, -5, 5), new Vec3(-10, 0, 0), new Vec3(0, 0, -10), material);\r\n// objects.push(plane);\r\n\r\n// material = new Material(diffuseBRDF, { baseColor: new Vec3(1, 1, 1) });\r\n// plane = new Plane(new Vec3(5, 5, 5), new Vec3(-10, 0, 0), new Vec3(0, 0, -3), material);\r\n// objects.push(plane);\r\n// plane = new Plane(new Vec3(5, 5, -2), new Vec3(-10, 0, 0), new Vec3(0, 0, -3), material);\r\n// objects.push(plane);\r\n// plane = new Plane(new Vec3(5, 5, 2), new Vec3(-3, 0, 0), new Vec3(0, 0, -4), material);\r\n// objects.push(plane);\r\n// plane = new Plane(new Vec3(-2, 5, 2), new Vec3(-3, 0, 0), new Vec3(0, 0, -4), material);\r\n// objects.push(plane);\r\n\r\n// material = new Material(emissionBRDF, { baseColor: new Vec3(8, 8, 8) });\r\n// plane = new Plane(new Vec3(2, 5, 2), new Vec3(-4, 0, 0), new Vec3(0, 0, -4), material);\r\n// objects.push(plane);\r\n\r\n\r\n// HO\r\nlet material = new Material(diffuseBRDF, { baseColor: new Vec3(1, 1, 1) });\r\nlet sphere = new Sphere(new Vec3(-3, 0, 0), 3, material);\r\nobjects.push(sphere);\r\nmaterial = new Material(diffuseBRDF, { baseColor: new Vec3(1, 0, 0) });\r\nsphere = new Sphere(new Vec3(3, 0, 0), 3, material);\r\nobjects.push(sphere);\r\n\r\nlet light = new DirectionalLight(new Vec3(1, -1, -1), new Vec3(1, 1, 1));\r\nobjects.push(light);\r\n\r\ncamera.setView(new Vec3(0, 0, -10), new Vec3(0, 0, 0), new Vec3(0, 1, 0));\r\ncamera.focus = 5;","import { camera, objects } from \"./scene\";\r\nimport { Vec2, Vec3 } from \"./RMath\";\r\nimport { Ray } from './Ray';\r\n\r\nonmessage = (event) => {\r\n\tlet eventType = event.data.type;\r\n\tconst samplePerPixel = Math.pow(2, 15);\r\n\tif (eventType === 'initial') {\r\n\t\tconsole.log(`Render with ${samplePerPixel} samples per pixel`);\r\n\t\tcamera.size = new Vec2(event.data.cameraSize.x, event.data.cameraSize.y);\r\n\t\tcamera.canvasSize = new Vec2(event.data.canvasSize.x, event.data.canvasSize.y);\r\n\t} else if (eventType === 'renderRange') {\r\n\t\tlet rangeStart = event.data.rangeStart;\r\n\t\tlet rangeEnd = event.data.rangeEnd;\r\n\t\tlet width = rangeEnd.x - rangeStart.x;\r\n\t\tlet height = rangeEnd.y - rangeStart.y;\r\n\t\tlet data = new Uint8ClampedArray(width * height * 4);\r\n\t\tlet halfCameraSize = camera.size.divide(2);\r\n\t\tlet step = camera.size.divideByVec2(camera.canvasSize);\r\n\t\tlet focusPosition = camera.position.plus(camera.position.minus(camera.lookAt).scaleToLength(camera.focus));\r\n\r\n\t\tlet cameraTopLeft = camera.position.plus(camera.leftVector.multiply(halfCameraSize.x)).plus(camera.topVector.multiply(halfCameraSize.y));\r\n\t\tlet focusToTopLeft = cameraTopLeft.minus(focusPosition);\r\n\t\tfor (let x = rangeStart.x; x < rangeEnd.x; x++) {\r\n\t\t\tfor (let y = rangeStart.y; y < rangeEnd.y; y++) {\r\n\t\t\t\t// if (x === 234 && y === 565) {\r\n\t\t\t\t// \tstartDebugging();\r\n\t\t\t\t// } else {\r\n\t\t\t\t// \tstopDebugging();\r\n\t\t\t\t// }\r\n\t\t\t\tlet color = new Vec3(0, 0, 0);\r\n\t\t\t\tfor (let s = 0; s < samplePerPixel; s++) {\r\n\t\t\t\t\tlet samplePoint = camera.leftVector.multiply(step.x * (x + Math.random())).plus(camera.topVector.multiply(step.y * (y + Math.random())));\r\n\t\t\t\t\tlet rays = [new Ray(focusPosition, focusToTopLeft.minus(samplePoint).normalize(), 0, 1)];\r\n\t\t\t\t\tcolor = color.plus(traceRay(rays, objects));\r\n\t\t\t\t}\r\n\t\t\t\tcolor = color.divide(samplePerPixel);\r\n\r\n\t\t\t\tlet index = ((y - rangeStart.y) * width + (x - rangeStart.x)) * 4;\r\n\t\t\t\tdata[index++] = color.x * 255;\r\n\t\t\t\tdata[index++] = color.y * 255;\r\n\t\t\t\tdata[index++] = color.z * 255;\r\n\t\t\t\tdata[index++] = 255;\r\n\t\t\t}\r\n\t\t}\r\n\t\tpostMessage({\r\n\t\t\ttype: 'doneRender'\r\n\t\t\t, x: rangeStart.x\r\n\t\t\t, y: rangeStart.y\r\n\t\t\t, width: width\r\n\t\t\t, height: height\r\n\t\t\t, data: data\r\n\t\t});\r\n\t}\r\n};\r\n\r\nfunction traceRay(rays, objects) {\r\n\tlet color = new Vec3(0, 0, 0);\r\n\tfor (let ray of rays) {\r\n\t\tif (ray.iterationCounter > 8) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tlet distance = Number.POSITIVE_INFINITY;\r\n\t\tlet collisionFunction = null;\r\n\t\tfor (let object of objects) {\r\n\t\t\tlet collision = object.getCollision(ray);\r\n\t\t\tlet d = collision.next().value;\r\n\t\t\tif (d < distance) {\r\n\t\t\t\tdistance = d;\r\n\t\t\t\tcollisionFunction = collision;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (distance === Number.POSITIVE_INFINITY) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tlet newRays = collisionFunction.next().value;\r\n\r\n\t\tif (newRays === null) {\r\n\t\t\tcolor = color.plus(collisionFunction.next().value.multiply(ray.weight).multiplyByVec3(ray.absort));\r\n\r\n\t\t} else {\r\n\t\t\tcolor = color.plus(traceRay(newRays, objects).multiply(ray.weight).multiplyByVec3(ray.absort));\r\n\t\t}\r\n\t}\r\n\treturn color;\r\n}\r\n"],"sourceRoot":""}